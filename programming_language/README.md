## Разработка и реализации интерпретатора модельного языка программирования
### Пшеничников Глeб, Потапова Наталья

_Написано на C++_

Программа состоит из нескольких модулей:    
* **scanner** - реализует лексический анализ;
* **parser** - реализует синтаксический анализ и семантический анализ, делает poliz
*  **execute** - реализия poliz;  

Разберем каждый модуль по отдельности. 

## SCANNER
Эта часть содержит в себе два файла ```scanner.h``` и ```scanner.cpp```. В перовом содержится общая структура классов: 

* ```Value```- был создан для правильной обработки полизом переменных, которые могут иметь тип int, real, string, array of int or real, boolean. Иными словами, это унифицированный для всех типов переменных класс. Для каждого типа описано соответсвующее поле и соответсвующие функции, которые возвращают, заносят значения, тип. Так же добавлена обработка масссивов (создание массива и изменение его ячеек)

* ```Lex``` - класс, который содержит тип лексемы, ее значение (если оно есть). Имеется несколько конструкторов (для каждого типа), так же описаны функции, возвращаюие тип, значение лексемы, строчку и позиции в ней, в которых находится лексема (надо для обработки исключений)

* ```Ident``` - класс для переменных, в нем имеется отдельные поля для каждого типа, а также поля, отвечаюште, было ли данная переменная инициализирована и было ли задано ее значение. Так же описаны функции, возвращающие тип, значение, имя данной перменной (для каждого типа предусмотрена своя функция, в том числе для массивов)
* ```Sanner``` - основной класс, в котором будет производиться разделение на лексемы. Содержит в себе массивы TW - ключевых слов, TD - ключевых знаков. Также описаны функции для раюоты с переменной, которые определяют и запоминают имя, значение, тип данной переменной в TID
* ```Except```- класс исключений. Описаны несколько конструкторов для разных выдов ошибок (ошибочный символ, ошибочная лексема и тд). Так же здесь определяется строка ошибки и ее место в строке  

В ```scanner.cpp``` содержитяс описание этих функций, описанных выше:  
* ```Scanner::Scanner(const char *program) ``` -  открывает файл на чтение

* ```int put(const string &buf) ``` - вызывается при встрече переменной, добавляет ее в TID и возвращает позицию или возвращает ее позицию, если она уже была добавлена ранее

* ```int Scanner::look(const string buf, const char ** list)``` - ищет переданную на вход лексему в переданном на вход списке (TD or TW). Это нужно для того, чтобы определеить является ли данная лексема подходящей или ошибочной

* ```void Scanner::gc()``` - считывает из stdin новый символ, при этом корректируя номер строки и позицию в ней
* ```Lex Scanner::get_lex() ``` - главная функция, которая создат лексемы. Она реализована по методу графа, где, исходя из стостояний, производятся соответсвуюшие действия:  
    *  H -  начальное и самое базовое состояние, из которого перемещаемся в другие. Здесь считываетс первый символ и, исходя из его значения, перемещаемся в нужную вершину графа
    * IDENT - здесь накапливается имя перменной и потом размещают ее в TID
    * NUMB - накопление целочисленной перменной по схеме Горнера
    * COM - обработка комемнтариев, которые не влияют на код
    * ALE - обработка логический операторов (присваивание, больше-меньше)
    * NEQ - обработка случая !=
    * REAL - обработка вещестенных чисел (по схеме Горнера)
    * STR - обработка стоковых переменных
* ```ostream &operator<<(ostream &s, Lex l)``` - перегрузка оператора вывода для контроля работы программы: выводит значение лексемы и ее название 
* ```Except::Except(Lex c)``` - обработка ошибочной лексемы
* ```Except::Except(char c, int line, int row) ``` - обработка ошибочного символа
* ```Except::Except(const char * err_name, int line, int row``` - обработка ошибки с конкретным именем (например, деление на 0)



## PARSER
Эта часть содержит в себе два файла ```parser.h``` и ```parser.cpp```. В перовом содержится общая структура класса ```Parser``` -  содержит функции для реализации рекурсивного спуска, проверки корректности операндов, переменных и тд.   
В ```parser.cpp``` содержится описание этих функций: 

* ```void Parser::getlex()``` - возвращает новую лексему при помощи функции __get_lex__ из модуля scanner 

* ```void Parser::analyze() ``` - начальная функци анализа, из которой начинается работа программы 

* ```void Parser::P() ``` - проверка на ключевое слово programm, вызов _D1_ и _B_

* ```void Parser::D1()``` - обработка поля var (определение типов переменных)
* ```void Parser::D()``` - обработка самих переменных из поля var
* ```void Parser::D_A()``` - обработка массивов в поле var
* ```void Parser::dec(type_of_lex type)``` - добавление на локальных стек переменных для отслеживания уникальности имен
* ```void Parser::dec_array(type_of_lex type, int array_size) ``` - добавление на локальных стек массивов для отслеживания уникальности имен
* ```void Parser::B()``` - с этой функции начинается обработка главной части программы 
* ```void Parser::S() ``` - в этой функции описаны все методы и возможности языка: 
    * IF - обработка условных оперторов (может быть без блока else)
    * WHILE - обработка цикла
    * READ - чтение переменных
    * WRITE - вывод переменных
    * CASE - множественный условный оператор
    * REPEAT - цикл номер 2
    * FOR - цикл номер 3
    * ID - обработка перменных
* ```void Parser::E_A()``` - обработка массивов (для работы с элементами его)
* ```void Parser::E()``` - функция арифметических операций
* ```void Parser::E1()``` - функция сложени, вычитания, or
* ```void Parser::T()``` - фукнция * / % and
* ```void Parser::F() ``` - функция по определению типа и значения переменных
* ```void Parser::check_id()``` - проверка была ли записана переменная в var
* ```void Parser::check_case()``` -проверка для оператора case 
* ```void Parser::check_op()``` - проверка для арифметических и логических операций на типы переменных
* ```void Parser::check_not() ``` - проверка для опертора not
* ```void Parser::eq_type() ``` - проверка совместимости типов
* ```void Parser::eq_bool()```- проверка является ли данная перменная типа bool
* ```void Parser::check_id_in_read() ``` -проверка на объявленность переменной
* ```void Parser::stack_clean()``` - отчистка стека 



## EXECUTE
Эта часть содержит в себе два файла ```execute.h``` и ```execute.cpp```. В перовом содержится общая структура класса ```Executer``` -  обработка полиза; ```Interpretator ``` -  конечный класс.
В ```execute.cpp``` содержится описание этих функций:
* ```void Executer::execute(std::vector<Lex>& poliz)``` -  обработка всех возможных операций в полизе:  

    * True, false, num, address, label - просто берем значения из поля  

    * Pop - очищаем стек
    * Real - обработка вещественных переменных
    * String - обработка строк
    * ID - обработка переменных
    * Not - опертора not
    * Or - опертора or
    * And - опертора and
    * Go -безусловный перехож
    * Fgo - переход по условию
    * Write - печать
    * Read - чтение
    * Plus - сложение
    * Minus - вычитнание
    * Times - умножение
    * Slash - деление
    * Procent - остаток от деления
    * Assign - присваивание
    * Арифметические сравнения
    * Array - обрабока массивов
    * Fin - конец обработки

* ```void Interpretator::interpretation()``` - конечная функция для обработки кода 


## MAIN
Для тестировки программы

## Запуск и компиляция
```
make clean
make 
make run ARGS="test.txt"
```
